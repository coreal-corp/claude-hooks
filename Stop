#!/usr/bin/env python3
"""
Stop Hook - Cross-platform version
Sends detailed completion notification to Slack
"""
import sys
import json
import os
import tempfile
import subprocess
import time
from pathlib import Path
from datetime import datetime
import urllib.request
import urllib.error


def load_env_file(env_path):
    """Load environment variables from .env file"""
    env_vars = {}
    if not os.path.exists(env_path):
        return env_vars

    with open(env_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                env_vars[key.strip()] = value.strip().strip('"').strip("'")
    return env_vars


def log_debug(message):
    """Write debug log"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    debug_log = Path(tempfile.gettempdir()) / 'claude-hook-debug.log'
    try:
        with open(debug_log, 'a', encoding='utf-8') as f:
            f.write(f"[{timestamp}] {message}\n")
    except:
        pass


def check_duplicate_lock(transcript_path):
    """Check and set duplicate execution lock"""
    if not transcript_path:
        return False

    transcript_name = Path(transcript_path).stem
    lock_file = Path(tempfile.gettempdir()) / f'.claude-stop-{transcript_name}'

    if lock_file.exists():
        try:
            with open(lock_file, 'r') as f:
                lock_time = int(f.read().strip())
            current_time = int(time.time())
            if current_time - lock_time < 3:
                log_debug(f"Duplicate execution prevented ({current_time - lock_time}s ago)")
                return True
        except:
            pass

    # Set new lock
    try:
        with open(lock_file, 'w') as f:
            f.write(str(int(time.time())))
    except:
        pass

    return False


def analyze_transcript(transcript_path, analyzer_script):
    """Analyze transcript using Python analyzer"""
    if not os.path.exists(transcript_path):
        return {}

    if not os.path.exists(analyzer_script):
        log_debug(f"Analyzer not found: {analyzer_script}")
        return {}

    try:
        result = subprocess.run(
            [sys.executable, analyzer_script, transcript_path],
            capture_output=True,
            text=True,
            encoding='utf-8'
        )
        log_debug(f"Analysis result:\n{result.stdout}")
        return parse_analysis(result.stdout)
    except Exception as e:
        log_debug(f"Analysis error: {str(e)}")
        return {}


def parse_analysis(analysis_text):
    """Parse analysis output into structured data"""
    data = {
        'command_summary': '',
        'todos': [],
        'thinking': [],
        'plan': []
    }

    lines = analysis_text.strip().split('\n')
    section = None

    for line in lines:
        line = line.strip()
        if line == 'COMMAND_SUMMARY_START':
            section = 'command_summary'
        elif line == 'COMMAND_SUMMARY_END':
            section = None
        elif line == 'TODOS_START':
            section = 'todos'
        elif line == 'TODOS_END':
            section = None
        elif line == 'THINKING_START':
            section = 'thinking'
        elif line == 'THINKING_END':
            section = None
        elif line == 'PLAN_START':
            section = 'plan'
        elif line == 'PLAN_END':
            section = None
        elif section == 'command_summary' and line:
            data['command_summary'] = line
        elif section == 'todos' and line:
            data['todos'].append(line)
        elif section == 'thinking' and line:
            data['thinking'].append(line)
        elif section == 'plan' and line:
            data['plan'].append(line)

    return data


def send_slack_message(token, channel, message, title="âœ… ìž‘ì—… ì™„ë£Œ"):
    """Send completion message to Slack"""
    url = "https://slack.com/api/chat.postMessage"

    payload = {
        "channel": channel,
        "text": title,
        "blocks": [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": title,
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": message
                }
            }
        ]
    }

    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }

    try:
        req = urllib.request.Request(
            url,
            data=json.dumps(payload).encode('utf-8'),
            headers=headers
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            return result.get('ok', False)
    except Exception as e:
        log_debug(f"Slack API error: {str(e)}")
        return False


def cleanup_lock_file(lock_file, delay=30):
    """Schedule lock file cleanup after delay"""
    import threading

    def cleanup():
        time.sleep(delay)
        try:
            if os.path.exists(lock_file):
                os.remove(lock_file)
        except:
            pass

    thread = threading.Thread(target=cleanup, daemon=True)
    thread.start()


def main():
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    log_debug(f"Stop hook started")

    # Read input from stdin
    try:
        input_data = json.load(sys.stdin)
    except:
        input_data = {}

    transcript_path = input_data.get('transcript_path', '')

    # Check for duplicate execution
    if check_duplicate_lock(transcript_path):
        sys.exit(0)

    # Load environment variables
    env_file = Path.home() / '.ultrathink.env'
    env_vars = load_env_file(env_file)

    slack_token = env_vars.get('SLACK_BOT_TOKEN')
    slack_channel = env_vars.get('SLACK_CHANNEL_ID', 'C09J29WDSHK')
    slack_channel = slack_channel.lstrip('#')

    work_dir = os.getcwd()

    log_debug(f"Transcript: {transcript_path}")

    # Analyze transcript
    analysis = {}
    command_summary = ""
    if transcript_path and os.path.exists(transcript_path):
        script_dir = Path(__file__).parent
        analyzer_script = script_dir / 'analyze_transcript.py'
        analysis = analyze_transcript(transcript_path, analyzer_script)
        command_summary = analysis.get('command_summary', '')

    # Build message with command summary as header
    message_parts = []

    # Add command summary as first line if available
    if command_summary:
        message_parts.append(f"*ìž‘ì—…:* {command_summary}\n")

    # Plan (if exists)
    if analysis.get('plan'):
        plan_text = '\n'.join(analysis['plan'])
        message_parts.append(f"ðŸ“‹ *ìž‘ì—… ê³„íš:*\n{plan_text}")

    # Todos
    if analysis.get('todos'):
        todos_text = '\n'.join(analysis['todos'])
        message_parts.append(f"\nðŸ“‹ *ìž‘ì—… ë‚´ìš©:*\n{todos_text}")

    # Thinking
    if analysis.get('thinking'):
        thinking_text = '\n'.join(analysis['thinking'])
        message_parts.append(f"\nðŸ’­ *ê²€í†  ì‚¬í•­:*\n{thinking_text}")

    # Project path at bottom
    message_parts.append(f"\n:open_file_folder: í”„ë¡œì íŠ¸: `{work_dir}`")

    full_message = '\n'.join(message_parts) if message_parts else f"ìž‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n\n:open_file_folder: í”„ë¡œì íŠ¸: `{work_dir}`"

    # Create title with command summary
    slack_title = f"âœ… ìž‘ì—… ì™„ë£Œ: {command_summary}" if command_summary else "âœ… ìž‘ì—… ì™„ë£Œ"

    log_debug("Sending to Slack")

    # Send to Slack
    if slack_token:
        success = send_slack_message(slack_token, slack_channel, full_message, slack_title)
        if success:
            log_debug("Slack message sent successfully")
        else:
            log_debug("Slack message failed")

    # Auto-push to GitLab if enabled and changes detected
    try:
        script_dir = Path(__file__).parent
        gitlab_pusher = script_dir / 'auto_push_gitlab.py'
        if gitlab_pusher.exists():
            result = subprocess.run(
                [sys.executable, str(gitlab_pusher)],
                capture_output=True,
                text=True,
                timeout=60
            )
            if result.returncode == 0 and result.stdout.strip():
                # Send GitLab push notification to Slack
                if slack_token:
                    push_message = f"ðŸ”„ *GitLab ë™ê¸°í™” ì™„ë£Œ*\n\n{result.stdout.strip()}\n\n:open_file_folder: í”„ë¡œì íŠ¸: `{work_dir}`"
                    send_slack_message(slack_token, slack_channel, push_message)
                    log_debug(f"GitLab push completed: {result.stdout.strip()}")
    except Exception as e:
        log_debug(f"GitLab push error: {str(e)}")
        pass  # Don't fail the hook if GitLab push fails

    # Schedule lock file cleanup
    if transcript_path:
        transcript_name = Path(transcript_path).stem
        lock_file = Path(tempfile.gettempdir()) / f'.claude-stop-{transcript_name}'
        cleanup_lock_file(str(lock_file))


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        # Log error but don't fail
        log_debug(f"Stop hook error (non-fatal): {str(e)}")
        pass
    finally:
        # Always exit successfully to avoid UI errors
        sys.exit(0)
